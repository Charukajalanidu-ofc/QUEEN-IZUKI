const config = require('../config')
const { cmd, commands } = require('../command')
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson} = require('../lib/functions')
const { pinterest, wallpaper, wikimedia, quotesAnime, aiovideodl, umma, ringtone, styletext } = require('../lib/scraper')
const gis = require('async-g-i-s');
const {unsplash, pixabay} = require("@sl-code-lords/image-library")

var imgmsg =''
if(config.LANG === 'SI') imgmsg = "```à¶šà¶»à·”à¶«à·à¶šà¶» à·€à¶ à¶± à¶šà·’à·„à·’à¶´à¶ºà¶šà·Š à¶½à·’à¶ºà¶±à·Šà¶±!```"
else imgmsg = "```Please write a few words!```"

var desc =''
if(config.LANG === 'SI') desc = "à¶œà·–à¶œà¶½à·Š à·„à·’ à¶…à¶¯à·à·… à¶´à·’à¶±à·Šà¶­à·–à¶» à·ƒà·™à·€à·“à¶¸."
else desc = "Search for related pics on Google."

var desc2 =''
if(config.LANG === 'SI') desc2 = "unsplash.com à·„à·’ à¶…à¶¯à·à·… à¶´à·’à¶±à·Šà¶­à·–à¶» à·ƒà·™à·€à·“à¶¸."
else desc2 = "Search for related pics on unsplash.com."

var desc3 =''
if(config.LANG === 'SI') desc3 = "pixabay.com à·„à·’ à¶…à¶¯à·à·… à¶´à·’à¶±à·Šà¶­à·–à¶» à·ƒà·™à·€à·“à¶¸."
else desc3 = "Search for related pics on pixabay.com."

var desc4 =''
if(config.LANG === 'SI') desc4 = "bing à·„à·’ à¶…à¶¯à·à·… à¶´à·’à¶±à·Šà¶­à·–à¶» à·ƒà·™à·€à·“à¶¸."
else desc4 = "Searche for related pics on bing."

var errt =''
if(config.LANG === 'SI') errt = "*à¶¸à¶§ à¶šà·’à·ƒà·’à·€à¶šà·Š à·ƒà·œà¶ºà·à¶œà¶­ à¶±à·œà·„à·à¶šà·’ à·€à·’à¶º :(*"
else errt = "*I couldn't find anything :(*"





cmd({
    pattern: "img1",
    react: 'ðŸ–¼ï¸',
    desc: desc2,
    category: "",
    use: '.img2 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await unsplash.search({"query": q, page: 1})
let data = results
if (data.result.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < 9; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data.result[i]
});
}
const sections = [{
title: "Result from unsplash.com. ðŸ“²",
rows: srh
}]
const listMessage = { 
text: `[ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š]

   *IMG DOWNLOADER 02*

*ðŸ–¼ï¸ Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from unsplash.com. ðŸ“²',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img2",
    react: 'ðŸ–¼ï¸',
    desc: desc3,
    category: "",
    use: '.img3 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await pixabay.search({"query": q, page: 1})
let data = results
if (data.result.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < 9; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data.result[i]
});
}
const sections = [{
title: "Result from pixabay.com. ðŸ“²",
rows: srh
}]
const listMessage = { 
text: `[ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š]

   *IMG DOWNLOADER 03*

*ðŸ–¼ï¸ Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from pixabay.com. ðŸ“²',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img3",
    react: 'ðŸ–¼ï¸',
    desc: desc4,
    category: "",
    use: '.img4 car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await fetchJson('https://api.akuari.my.id/search/bingimage?query=' + q)
let data = results.hasil
if (data.results.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < 9; i++) {
srh.push({
title: i + 1,
description: data.results[i].title ,
rowId: prefix + 'dimg ' + data.results[i].direct
});
}
const sections = [{
title: "Result from bing ðŸ“²",
rows: srh
}]
const listMessage = { 
text: `[ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š]

   *IMG DOWNLOADER 04*

*ðŸ–¼ï¸ Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from bing ðŸ“²',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "img4",
    react: 'ðŸ–¼ï¸',
    desc: desc,
    category: "download",
    use: '.img car',
    filename: __filename
},
async(conn, mek, m,{from, l, prefix, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) return await  reply(imgmsg)
const results = await gis(q);
let data = results.slice(0, 100)
if (data.length < 1) return await conn.sendMessage(from, { text: N_FOUND }, { quoted: mek } )
var srh = [];  
let nombor = 1
for (var i = 0; i < 9; i++) {
srh.push({
title: i + 1,
description: 'Image number: ' + nombor++ ,
rowId: prefix + 'dimg ' + data[i].url
});
}
const sections = [{
title: "Result from google. ðŸ“²",
rows: srh
}]
const listMessage = { 
text: `[ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š]

   *IMG DOWNLOADER 01*

*ðŸ–¼ï¸ Image Name:* ${q}`,
footer: config.FOOTER,
title: 'Result from google. ðŸ“²',
buttonText: 'Select Image',
sections
}
await conn.replyList(from, listMessage,{quoted: mek})

} catch (e) {
reply(errt)
l(e)
}
})

cmd({
    pattern: "dimg",
    dontAddCommandList: true,
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    await conn.sendMessage(from, { react: { text: 'ðŸ”ƒ', key: mek.key }})
    await conn.sendMessage(from, { image: { url: q }, caption: config.FOOTER }, { quoted: mek })
    await conn.sendMessage(from, { react: { text: 'âœ”', key: mek.key }})
} catch (e) {
    reply(errt)
  l(e)
}
})



cmd({
    pattern: "wallpaper",
    react: "ðŸ”–",
    desc: "image downloader",
    category: "download",
    use: '.wallpaper',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
        let { wallpaper } = require('../lib/scraper')
                                  anu = await wallpaper(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                          
              const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'wallpaper ' + q , description: 'NEXT  PIC âž¡ï¸'},

	]
    } 
]      
                                  const listMessage = {
  image: { url: result.image[0] },
      caption: `ðŸ”® ð—§ð—œð—§ð—Ÿð—˜ : ${result.title}\nðŸ”® ð—–ð—”ð—§ð—˜ð—šð—¢ð—¥ð—¬ : ${result.type}\nðŸ”® ð——ð—˜ð—§ð—”ð—œð—Ÿ : ${result.source}\nðŸ”® ð— ð—˜ð——ð—œð—” ð—¨ð—¥ð—Ÿ : ${result.image[2] || result.image[1] || result.image[0]}`,
      footer: config.FOOTER,
      buttonText: "ðŸ”¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š',
					body: 'á´€É´ á´œêœ±á´‡Ê€ Ê™á´á´› êœ°á´Ê€ á´¡Êœá´€á´›êœ±á´€á´˜á´˜',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})

cmd({
    pattern: "wikimedia",
    react: "ðŸ”–",
    desc: "to download wikimedia",
    category: "download",
    use: '.wikimedia',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
    let { wikimedia } = require('../lib/scraper')
                                  anu = await wikimedia(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'wikimedia ' + q , description: 'NEXT  PIC âž¡ï¸'},

	]
    } 
]      
                                  const listMessage = {
 image: { url: result.image[0] },
      caption: `ðŸ”® ð—§ð—œð—§ð—Ÿð—˜ : ${result.title}\nðŸ”® ð—–ð—”ð—§ð—˜ð—šð—¢ð—¥ð—¬ : ${result.type}\nðŸ”® ð——ð—˜ð—§ð—”ð—œð—Ÿ : ${result.source}\nðŸ”® ð— ð—˜ð——ð—œð—” ð—¨ð—¥ð—Ÿ : ${result.image[2] || result.image[1] || result.image[0]}`,
      footer: config.FOOTER,
      buttonText: "ðŸ”¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š',
					body: 'á´€É´ á´œêœ±á´‡Ê€ Ê™á´á´› êœ°á´Ê€ á´¡Êœá´€á´›êœ±á´€á´˜á´˜',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})

cmd({
    pattern: "pindl",
    react: "ðŸ”–",
    desc: "download pinterest images",
    category: "download",
    use: '.pindl',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
                                                                   
                                  
                                  let { pinterest } = require('../lib/scraper')
                                  anu = await pinterest(q)
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  conn.sendMessage(mek.chat, { image: { url: result }, caption: 'ðŸ”® Media Url : '+result }, { quoted: mek })
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})



cmd({
    pattern: "quotesanime",
    react: "ðŸ”–",
    desc: "to download animes",
    category: "download",
    use: '.quotesanime',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    let teks = 'Enter Query Title'
         let { quotesAnime } = require('../lib/scraper')
                                  let anu = await quotesAnime()
                                  result = anu[Math.floor(Math.random() * anu.length)]
                                  const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'quotesanime ' + q , description: 'NEXT  PIC âž¡ï¸'}

	]
    } 
]      
                                  const listMessage = {
 text: `~_${result.quotes}_\n\nBy '${result.karakter}', ${result.anime}\n\n- ${result.up_at}`,
                                      footer: config.FOOTER,
                                      buttonText: "ðŸ”¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š',
					body: 'á´€É´ á´œêœ±á´‡Ê€ Ê™á´á´› êœ°á´Ê€ á´¡Êœá´€á´›êœ±á´€á´˜á´˜',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})



cmd({
    pattern: "coffe",
    react: "ðŸ”–",
    desc: "to download coffe",
    category: "download",
    use: '.coffe',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
    await conn.sendMessage(from, { react: { text: `â˜•`, key: mek.key }})
                              const sections = [
    {
	title: "",
	rows: [
	    {title: "1", rowId: prefix + 'coffe ' + q , description: 'NEXT  PIC âž¡ï¸'}

	]
    } 
]      
                                  const listMessage = {
 image: { url: 'https://coffee.alexflipnote.dev/random' },
                                      caption: `Random Coffee`,
                                      footer: config.FOOTER,
                                      buttonText: "ðŸ”¢ Reply below number,",
  sections,
  contextInfo: {
				
				externalAdReply: { 
					title: 'ðŸ§š ï¼±ï¼µï¼¥ï¼¥ï¼® -ï¼©ï¼ºï¼µï¼­ï¼© - ï¼­ï¼¤ ðŸ§š',
					body: 'á´€É´ á´œêœ±á´‡Ê€ Ê™á´á´› êœ°á´Ê€ á´¡Êœá´€á´›êœ±á´€á´˜á´˜',
					mediaType: 1,
					sourceUrl: "" ,
          thumbnailUrl: 'https://telegra.ph/file/ba8ea739e63bf28c30b37.jpg' ,
					renderLargerThumbnail: false,
          showAdAttribution: true
         }}	
}
 
return await conn.replyList(from, listMessage ,{ quoted : mek }) 
} catch (e) {
reply(N_FOUND)
l(e)
}
})

cmd({
    pattern: "ringtone",
    react: "ðŸ”–",
    desc: "to download ringtone",
    category: "download",
    use: '.ringtone',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
if (!q) reply `${Lang.EXAMPLE}\n : ${prefix + command} black rover`
                          let { ringtone } = require('../lib/scraper')
                          let anu = await ringtone(q)
                          let result = anu[Math.floor(Math.random() * anu.length)]
                          conn.sendMessage(mek.chat, { audio: { url: result.audio }, fileName: result.title+'.mp3', mimetype: 'audio/mpeg' }, { quoted: mek })
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})



cmd({
    pattern: "wpaper",
    react: "ðŸ”–",
    desc: "to download wpaper",
    category: "download",
    use: '.wpaper',
    filename: __filename
},
async(conn, mek, m,{from, l, quoted, prefix, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply}) => {
try{
  let teks = '*LOADING...*'
    await conn.sendMessage(mek.chat, { image: { url: `https://api.akuari.my.id/search/alphacoders?query=${q}` },  caption: `${config.cap}`}, { quoted: mek }),
   await conn.sendMessage(mek.chat, { image: { url: `https://api.akuari.my.id/search/alphacoders?query=${q}` },  caption: `${config.cap}`}, { quoted: mek }.repeat(5))
await conn.sendMessage(from, { react: { text: `âœ…`, key: mek.key }}) 
} catch (e) {
reply()
l(e)
}
})
